\paragraph{\ref{ch:arch}.\ref{ex:arch:chess}}

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[
        basicstyle=\large\ttfamily,
        xleftmargin=5em,
    ]
     A   B   C   D   E   F   G   H
   +-------------------------------+
 8 | r |:n:| b |:q:| k |:b:| n |:r:|
   |---+---+---+---+---+---+---+---|
 7 |:p:| p |:p:| p |:p:| p |:p:| p |
   |---+---+---+---+---+---+---+---|
 6 |   |:::|   |:::|   |:::|   |:::|
   |---+---+---+---+---+---+---+---|
 5 |:::|   |:::|   |:::|   |:::|   |
   |---+---+---+---+---+---+---+---|
 4 |   |:::|   |:::|   |:::|   |:::|
   |---+---+---+---+---+---+---+---|
 3 |:::|   |:::|   |:::|   |:::|   |
   |---+---+---+---+---+---+---+---|
 2 | P |:P:| P |:P:| P |:P:| P |:P:|
   |---+---+---+---+---+---+---+---|
 1 |:R:| N |:B:| Q |:K:| B |:N:| R |
   +-------------------------------+
 0. 8 pawns   (p)   3. 2 bishops (b)
 1. 2 rooks   (r)   4. 1 queen   (q)
 2. 2 knights (n)   5. 1 king    (k)
    \end{lstlisting}
    \caption{Chess board}
    \label{fig:sol:chess}
\end{figure}

A chess board consists of an 8x8 grid with two identical sets, except for the
color, of sixteen pieces each.  Usually the colors of sets are white and black.
In addition, every piece of the same type and color is interchangeable: all
white pawns are equal, etc.  Figure \ref{fig:sol:chess} shows a representation
of the initial disposition of the pieces on the board using standard chess
notation, with the pieces represented each by one character as described in the
text below it.  White pieces are shown in capital letters and black positions on
the board have the shading character sequence \texttt{:::}.

An initial design for the storage is as a one- or two-dimensional array of total
size 64, with each element corresponding to one position in a predefined order
(e.g. row-major in board order).  Any given position can be empty or contain one
of the six types of pieces of one of the two colors.  The empty position and the
six piece types fit into three bits with one unused value, a fourth bit can hold
the color.  All the information for a position is encoded in 4 bits (half a
byte).  Thus, the total space required for this representation is:
\begin{align*}
    8 \times 8 \times 4 = 256\text{ bits} = 32\text{ bytes}
\end{align*}

Listing \ref{lst:sol:chess0} shows this implementation.  However, storing
information for empty positions is wasteful, specially as the game progresses
and the board becomes more sparse.  Even so, storing only the position data
along with an index does not reduce the storage requirement.  Storing the piece
and color still takes four bits (now with a second unused value), and six bits
are required for an index into the array ($\log_2 64 = 6$), yielding a total for
the initial board with all pieces for maximally packed (but now unaligned) data
of:
\begin{align*}
    32 \times 10 = 320\text{ bits} = 40\text{ bytes}
\end{align*}

A bitmap can be used to store the presence or absence of a piece at a given
position.  The 64 positions fit an 8-byte (64-bit) integer.  The same 4-bit
piece data as before can follow the bitmap in order for each non-empty position,
yielding a total for the initial configuration of the board of:
\begin{align*}
    64 + 4 \times 32 = 192\text{ bits} = 24\text{ bytes}
\end{align*}

Listing \ref{lst:sol:chess1} shows this implementation.  All omitted
declarations and definitions remain the same, except for the enumeration, which
now no longer has an \texttt{EMPTY} element.

\begin{figure}[p]
    \lstinputlisting[
        caption={Chess board storage},
        label={lst:sol:chess0},
        style=c,
        firstline=9,
        lastline=30,
    ]{sol/chess0.c}
    \lstinputlisting[
        caption={Chess board storage with bit set},
        label={lst:sol:chess1},
        style=c,
        firstline=37,
        lastline=52,
    ]{sol/chess1.c}
\end{figure}

\paragraph{\ref{ch:arch}.\ref{ex:arch:width_type:range}}

The maximum number of bits for a given integer type (i.e. its bit width) is
strictly less than the maximum value of that type\footnotemark.  However, it is
significantly \emph{less} than its maximum value in a sub-linear relationship.
Recall that the maximum value of an unsigned type of width $w$ is $2^w - 1$.
Therefore, the relationship between the maximum value and the maximum number of
bits is logarithmic.

\footnotetext{
    Ignoring the case of \texttt{CHAR\_BIT == 1}, where the size and width of
    \texttt{char} would be the same --- i.e. \texttt{1}.}

The sized types mentioned in the C11 standard (\cite{C2011}) are in the range
\texttt{uint8\_t} to \texttt{uint64\_t} (i.e. 8 to 64 bits wide), so the range
of \texttt{uint8\_t} is more than sufficient ($255 \gg 64$) to store the width
of these types.  There is no limit imposed on maximum width an implementation
can provide, however, so a larger type would have to be used if widths greater
than 255 exist.

\paragraph{\ref{ch:arch}.\ref{ex:arch:width_type:impl}}

This solution uses a type alias implemented as \texttt{decltype} of the return
value of a \texttt{consteval} function.

\begin{lstlisting}[style=c++,caption={\texttt{min\_type\_for\_width}}]
#include <bit>
#include <concepts>
#include <cstddef>
#include <cstdint>
#include <climits>

namespace detail {

template<std::size_t w>
consteval auto min_type_for_width_impl() {
    constexpr auto max = std::bit_width(w - 1);
    if constexpr(max < CHAR_BIT)
        return std::uint8_t{};
    else if constexpr(max < 2 * CHAR_BIT)
        return std::uint16_t{};
    else if constexpr(max < 4 * CHAR_BIT)
        return std::uint32_t{};
    else if constexpr(max < 8 * CHAR_BIT)
        return std::uint64_t{};
}

}

template<std::unsigned_integral T>
using min_type_for_width = decltype(
    detail::min_type_for_width_impl<sizeof(T) * CHAR_BIT>());
\end{lstlisting}

We can then assert that \texttt{uint8\_t} can be used for all standard sized
types:

\begin{lstlisting}[
    style=c++,
    caption={Tests for \texttt{min\_type\_for\_width}},
]
template<std::unsigned_integral T, std::unsigned_integral WT>
using check = std::is_same<min_type_for_width<T>, WT>;

static_assert(check<std::uint8_t, std::uint8_t>());
static_assert(check<std::uint16_t, std::uint8_t>());
static_assert(check<std::uint32_t, std::uint8_t>());
static_assert(check<std::uint64_t, std::uint8_t>());
\end{lstlisting}

Relaxing the type constraint allows us to check with fictitious integer types:

\begin{lstlisting}[
    style=c++,
    caption={Extended tests for \texttt{min\_type\_for\_width}},
]
#include <array>

template<typename T, std::unsigned_integral WT>
using check = std::is_same<min_type_for_width<T>, WT>;

template<std::size_t W>
using fake_uint = std::array<std::uint8_t, W / CHAR_BIT>;

static_assert(check<fake_uint<1ul << 7>, std::uint8_t>());
static_assert(check<fake_uint<1ul << 8>, std::uint16_t>());
static_assert(check<fake_uint<1ul << 15>, std::uint16_t>());
static_assert(check<fake_uint<1ul << 16>, std::uint32_t>());
static_assert(check<fake_uint<1ul << 31>, std::uint32_t>());
static_assert(check<fake_uint<1ul << 32>, std::uint64_t>());
\end{lstlisting}

\paragraph{\ref{ch:algo}.\ref{ex:algo:bsearch_middle}}

The expression \texttt{m = b + (e - b) / 2} is a bit unusual but a
mathematically correct way to obtain a value that is exactly between \texttt{b}
and \texttt{e}.  In the context of a binary search, \texttt{b} and \texttt{e}
are integer indices, not continuous variables, so it must be proven that the
expression correctly partitions the half-closed interval in two for every
possible value of \texttt{b} and \texttt{e}.

The base case of a range of length zero is trivial: both \texttt{b} and
\texttt{e - b} equal zero, so \texttt{m} is also zero\footnotemark.  $[b, m)$
and $[m, e)$ are both $[0, 0)$, are correct ranges, and the partition is in the
"middle".  As the size of the ranges increases, two cases are of interest: odd
and even lengths.  When the length of the range is even, the rounding division
is redundant since it is no different than regular division, which can be shown
to be equivalent to the original expression:

\footnotetext{
    Recall that, as mentioned in section \secref{subsec:algo:ranges}, the length
    calculation for half-open ranges is very simple: $|[b, e)| = e - b$.}

\begin{multicols}{3}
    \begin{align*}
        m &= b + \frac{e - b}{2} \\
          &= \frac{2b + e - b}{2} \\
          &= \frac{b + e}{2} \\
    \end{align*}
    \columnbreak
    \begin{align*} \\
        |[b, m)| &= m - b \phantom{\frac{1}{1}} \\
                 &= \frac{b + e}{2} - b \\
                 &= \frac{e - b}{2} \\
    \end{align*}
    \columnbreak
    \begin{align*} \\
        |[m, e)| &= e - m \phantom{\frac{1}{1}} \\
                 &= e - \frac{b + e}{2} \\
                 &= \frac{e - b}{2} \\
    \end{align*}
\end{multicols}

E.g.: partitioning the array \texttt{[0, 1, 2, 3]}, assuming for simplicity in
all examples that \texttt{b} is the beginning of the array at address
\texttt{0}, gives:

\begin{align*}
           m &= \frac{b + e}{2}
              = \frac{4}{2}
              = 2 \\\\
             &= b + \frac{e - b}{2}
              = 0 + \frac{4 - 0}{2}
              = \frac{4}{2}
              = 2 \\\\
    |[b, m)| &= m - b = 2 \\
    |[m, e)| &= e - m = 2 \\
\end{align*}

In the case of a range with odd length, one of the two sub-ranges has to have an
extra element.  Due to rounding, that is the second one since, for this case:

\begin{align*}
    \left\lfloor \frac{e - b}{2} \right\rfloor = \frac{e - b - 1}{2} \\
\end{align*}

This is safe for ranges of positive, odd length since $0 < e - b$.  The two
ranges are then:

\begin{align*}
                     m &= b + \left\lfloor \frac{e - b}{2} \right\rfloor
                        = \frac{2b + e - b - 1}{2}
                        = \frac{b + e - 1}{2} \\\\
              |[b, m)| &= m - b
                        = \frac{b + e - 1}{2} - b
                        = \frac{e - b - 1}{2} \\\\
              |[m, e)| &= e - m
                        = e - \frac{b + e - 1}{2}
                        = \frac{e - b + 1}{2} \\\\
    |[m, e)| - |[b, m) &= \frac{(e - b + 1) - (e - b - 1)}{2}
                        = \frac{2}{2}
                        = 1 \\
\end{align*}

E.g. for \texttt{[0, 1, 2]}:

\begin{align*}
          m &= 0 + \frac{3 - 0}{2}
             = \bigg \lfloor \frac{3}{2} \bigg \rfloor
             = 1 \\\\
    |m - b| &= 1 \qquad |e - m|
             = 2 \\
\end{align*}

We have therefore shown the following properties of the middle point expression
for ranges of different lengths:

\begin{itemize}
    \item Ranges of length zero remain the same.
    \item Ranges of even length are split evenly.
    \item
        Ranges of odd length are split into two ranges of even and odd length,
        respectively.
    \item
        For all lengths, the two resulting ranges are a sub-range of the
        original.
\end{itemize}

\paragraph{\ref{ch:algo}.\ref{ex:algo:bsearch_overflow}}

There are two problems with this alternative expression.  As we have seen in
section \secref{sec:c:ub}, pointer arithmetic is only valid inside the bounds of
an array, up to and including one past its end.  Therefore the expression
\texttt{b + e} is undefined since it is outside the defined bounds for any range
where \texttt{b} is not zero (practically, no object is ever stored at address
zero in most architectures).

Even if that were not the case, a second problem occurs when either \texttt{b}
or \texttt{e} are close to the end of the range of memory addresses.  Assuming
an architecture where pointers and integers are interconvertible for
illustrative purposes, if \texttt{e == (void*)SIZE\_MAX}, any non-zero value of
\texttt{b} will result in overflow, yielding an incorrect result after the
division and addition.

This problem does not exist in the original expression, as \texttt{e - b <= e}
and therefore a valid value as long as the value of the difference can be
represented by the \texttt{ptrdiff\_t} type.

\paragraph{\ref{ch:algo}.\ref{ex:algo:bsearch_bound}}

Binary search, lower bound, and upper bound are very similar algorithms, so
writing one after having written one of the others is simple, but rewriting
\texttt{binary\_search} requires careful attention to the invariants.

All three have the same iteration pattern: recursive binary partition based on a
predicate.  The crucial difference is in the comparisons that determine the
partitions.  As hinted in the exercise description, both lower and upper bound
allow us to perform a single comparison per iteration and to define the entire
algorithm in terms of a single comparison function, which makes writing generic
code (v. section \secrefpar{sec:c++:meta}) easier.

Let us consider the lower bound first.  We note that the conditional where
\texttt{*m} and \texttt{x} are tested for equality has to be removed, as the
search must proceed in that case if we are to find the leftmost occurrence.  It
may be surprising is that this is \emph{all} that is needed to implement the
algorithm, but if follows naturally from the adjusted loop invariants.

\lstinputlisting[style=c,firstline=8]{algo/lower_bound.c}

A few notable changes:

\begin{itemize}
    \item
        As mentioned previously, there is now a single comparison per iteration.
    \item
        Furthermore, all comparisons, including in the invariants, use a single
        operation: less than (this is the reason for the unusual spellings such
        as \texttt{!(*e < x)}.
    \item
        The invariant involving \texttt{e} now allows for \texttt{*e == x}.
        Similarly, the invariant which stated that \texttt{!lsearch(x, e, ie)}
        had to be removed.  In both cases, this is because duplicate elements
        are now allowed in the upper region.
\end{itemize}

From the last two loop invariants we know that when \texttt{b} is moved, it will
never point to a value that is greater than \texttt{x}.  Similarly, when
\texttt{e} is moved, it will never point to a value that is less than
\texttt{x}.  Then, the intersection of the two, where \texttt{b} is moved to
\texttt{e} in the final iteration of the loop (or when \texttt{e} is moved to
\texttt{b}, if \texttt{x} is smaller than all values in the range), must be the
lower bound.

Computing the upper bound follows a similar process.  All that is required is to
also choose the upper region of the range when \texttt{*m == x}.  We spell
the condition as \texttt{!(x < *m)} instead of \texttt{*m <= x} for the same
reason cited above.

\lstinputlisting[style=c]{algo/upper_bound.c}

To rewrite \texttt{binary\_search}, we note that the return value of
\texttt{lower\_bound} must be one of three cases:

\begin{itemize}
    \item
        \texttt{x} is larger than all values in the range.  The lower bound is
        \texttt{e}.
    \item \texttt{x} is in the range.  The element returned is equal to it.
    \item
        \texttt{x} is not in the range but smaller than some of the values in
        it.  The element returned is the beginning of the sequence that is
        greater than it.
\end{itemize}

\begin{lstlisting}[style=c]
bool bsearch(int x, int *b, int *e) {
    b = lower_bound(x, b, e);
    return b != e && !(x < *b);
}
\end{lstlisting}

Similarly for \texttt{upper\_bound}:

\begin{lstlisting}[style=c]
bool bsearch(int x, int *b, int *e) {
    e = upper_bound(x, b, e);
    return e != b && !(e[-1] < x);
}
\end{lstlisting}

\paragraph{\ref{ch:struct}.\ref{ex:struct:list_reverse}}

There are several ways to conceptualize the operations involved in the reversal
of a list.  One of them is to start with an empty list and continuously move one
element from the front of the old list to the front of the new one.  Always
pushing to the front of the new list effectively reverses the order of nodes.

\begin{lstlisting}[style=c]
struct node *list_reverse(struct node *n) {
    struct node *ret = NULL;
    for(struct node *next = NULL; n; n = next) {
        next = n->next;
        list_push_front(&ret, n);
    }
    return ret;
}
\end{lstlisting}

\paragraph{\ref{ch:struct}.\ref{ex:struct:list_remove}}

This exercise shows the benefit of treating the list head and links
homogeneously.  The function is passed a double pointer, so it can examine the
value in the node via a double dereference, but also modify the head or node
link pointer through it.  Figures \ref{fig:sol:list_remove0} and
\ref{fig:sol:list_remove1} show both cases.

\begin{lstlisting}[style=c]
struct node *list_remove(struct node **l, int value) {
    for(; *l; l = &(*l)->next) {
        if((*l)->value != value)
            continue;
        struct node *ret = *l;
        *l = ret->next;
        return ret;
    }
    return NULL;
}
\end{lstlisting}

\begin{figure}[p]
    \centering
    \input{sol/struct/list_remove0.tex}
    \caption{\texttt{list\_remove(\&l, 0)}}
    \label{fig:sol:list_remove0}
\end{figure}

\begin{figure}[p]
    \centering
    \input{sol/struct/list_remove1.tex}
    \caption{\texttt{list\_remove(\&l, 1)}}
    \label{fig:sol:list_remove1}
\end{figure}
