\section{Calling conventions}

The standard for function parameters that have no special qualification is
\textit{pass-by-value}: a function that declares a parameter of type \texttt{T}
receives a \emph{copy} of the argument.  An alternative is
\textit{pass-by-reference}, where either a pointer or a reference to the object
is passed.

Reference arguments avoid copying objects and are potentially a faster way to
pass objects that are large and/or expensive to copy.  Value arguments, however,
have several advantages and are usually preferred for types that are relatively
inexpensive to copy.  They are often stored in registries (according to the ABI,
see below), avoiding any sort of memory access.

References are also subject to \textit{aliasing}, where an object is referred to
by more than one name.  A compiler has to be conservative when manipulating
references and members of structures passed by reference and reload values from
memory when there is the possibility that they are aliased.  Because value
parameters are not located in memory, the compiler can aggressively optimize
access to them with the assumption that the parameter name is the only reference
to its value.

The particular manner in which objects are passed between functions depends on
the \textit{Application Binary Interface} of a particular platform.

\subsection{System V / Itanium ABI}

These are the C and C++ (respectively) ABIs adopted by most 64-bit Unix
derivatives (Linux, FreeBSD, Solaris, macOS, etc., v. \cite{SystemV2012} and
\cite{Itanium2017}).  In these conventions, integral (including pointers) and
floating-point values are passed in registers.  Six registers are designated for
the first six integral parameters (\texttt{rdi}, \texttt{rsi}, \texttt{rdx},
\texttt{rcx}, \texttt{r8}, and \texttt{r9}), eight for the first eight
floating-point parameters (\texttt{xmm0} to \texttt{xmm7}), in both cases in the
same order they appear in the function prototype.  Any remaining parameters are
passed via the call stack (listing \ref{lst:c++:abi_scalar}).

\begin{figure}[ht]
    {\setlength{\columnsep}{-8em}\begin{multicols}{2}
        \begin{lstlisting}[style=c]
#include <stdint.h>

void f(
    int8_t i8,
    int16_t i16,
    int32_t i32,
    int64_t i64,
    const char *s,
    const int *p,
    float f,
    double d,
    int64_t i64_0,
    int64_t i64_1);

void g(void) {
    int p = 5;
    f(
        0, 1, 2, 3, "", &p,
        6, 7, 8, 9);
}
        \end{lstlisting}
        \columnbreak
        \begin{lstlisting}[style=x86]
g:
    sub   rsp, 24
    mov   ecx, 3                    ; i64
    mov   edx, 2                    ; i32
    xor   edi, edi                  ; i8
    mov   DWORD PTR 12[rsp], 5      ; p
    movsd xmm1, QWORD PTR .LC0[rip] ; d
    lea   r8, .LC1[rip]             ; s
    mov   esi, 1                    ; i16
    push  9                         ; i64_1
    movss xmm0, DWORD PTR .LC2[rip] ; f
    push  8                         ; i64_0
    lea   r9, 28[rsp]               ; &p
    call  f@PLT
    add   rsp, 40
    ret
.LC0:
	.long	0
	.long	1075576832
	.align 4
.LC1:
	.string	""
.LC2:
	.long	1086324736
        \end{lstlisting}
    \end{multicols}}
    \caption{Scalar arguments passed by value}
    \label{lst:c++:abi_scalar}
\end{figure}

For aggregate types (\texttt{struct}s), the Itanium ABI discriminates based on
what it defines as \textit{non-trivial for the purpose of calls}: types whose
constructors and/or destructor are non-trivial, i.e. not generated by the
compiler.  A type is considered \textit{trivial}, as indicated by the type trait
\texttt{std::is\_trivial}, if it has only trivial constructors and destructor.

\texttt{struct}s of this category are always passed by reference to a function,
if the formal parameter is declared to be by-value.  The compiler will insert
the operations to place arguments on the stack (\textit{stack spilling}) if
necessary.

Trivial \texttt{struct} types are treated mostly as if each member were a
separate argument, following the same rules for register designation.
Additionally, members may be packed if more than one fit into a single register
(listing \ref{lst:c++:abi_struct}).

\begin{figure}[ht]
    \begin{multicols}{2}
        \begin{lstlisting}[style=c]
#include <stdint.h>

struct S { int32_t x, y; };

void f(struct S _);
void g(void) { f((struct S){0, 1}); }
        \end{lstlisting}
        \columnbreak
        \begin{lstlisting}[style=x86]
g:
    movabs rdi, 4294967296
    jmp    f@PLT
        \end{lstlisting}
    \end{multicols}
    \caption{Structural arguments passed by value}
    \label{lst:c++:abi_struct}
\end{figure}
