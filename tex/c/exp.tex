\section{Expressions}

\subsection{Pointers}

\texttt{NULL} pointer not necessarily zero value (e.g. C++ member pointers)

\begin{quote}
    [T]he name of the null pointer is ``0'', but the name of the null pointer is
    called ``NULL'' (and we're not sure what the null pointer is).
\end{quote}

\cite{Summit1995}

\subsection{Compound literals}

\label{subsec:c:literals}

C99 introduced a type of expression which declares a temporary value of
aggregate types (i.e.  array, \texttt{struct}, or \texttt{union}), called a
\textit{compound literal}.  The syntax is visually similar to a cast operation:

\begin{lstlisting}[style=c]
// Array literal.
// Note: could also be declared directly as an array in this case.
// int a[] = {0, 1, 2, 3};
int *a = (int[]){0, 1, 2, 3};
// `struct` literal.
struct S { int i; float f; };
struct S s = (struct S){.i = 42, .f = 3.1415f};
// `union` literal.
union U { int i; float f; };
union U u = (union U){.f = 3.1415f};
\end{lstlisting}

This type of literal can be used whenever a value would be defined for a single
use.  It has the advantage that it does not create an identifier for the value
which leaks into the surrounding scope.  In fact, there is no way to refer to
the value unless it is given a name explicitly, either via an assignment or
function parameter.

\begin{lstlisting}[style=c]
struct S {};
void f(struct S);
// Only `f` has access to the temporary value, via its parameter.
f((struct S){});
\end{lstlisting}

The syntax for the declaration of compound literals is similar to that of
aggregate initialization of a temporary value in C++:

\begin{lstlisting}[style=c++]
void f(int[]);
f(std::array{0, 1, 2, 3}.data());

struct S { int i; float f; };
void f(S);
f(S{.i = 42, .f = 3.1415f});

union U { int i; float f; };
void f(U);
f(U{.f = 3.1415f});
\end{lstlisting}

There is a very important semantic difference between the two languages,
however: the scope/lifetime of the temporary object when this type of
declaration occurs at block scope.  Because of the strict rules in C++ regarding
construction and destruction of objects (which can have arbitrary side effects),
the lifetime follows the same rules as any other type of temporary value, i.e.
it extends only to the end of the full expression where the object is used.  In
the previous examples, the objects are destroyed and inaccessible after the
semicolons following the expressions that declare them.

In C, the temporary object is assigned a duration according to its enclosing
scope.  A declaration at file scope assigns it static storage duration.  This is
virtually the same as when aggregate initialization is used in the definition of
an object with static storage duration in C++.  However, for declarations at
block scope, C assigns automatic storage duration just as if the object had been
defined as a local variable prior to the expression where it is used: its scope
spans the entire block where it is declared.  This makes code like the following
possible, where a temporary array is created as part of an expression and used
throughout the surrounding block:

\begin{lstlisting}[style=c]
#define FMT(buffer, fmt, ...) fmt_str((buffer), (fmt), __VA_ARGS__)

inline static char *fmt_str(
    char *restrict buffer, const char *restrict fmt, ...
) {
    va_list args;
    va_start(args, fmt);
    vsprintf(buffer, fmt, args);
    va_end(args);
    return buffer;
}

int main(void) {
    char *const s = FMT((char[128]){0}, "%s %d %f", "str", 42, 3.1415);
    puts(s);
}
\end{lstlisting}

An attempt to use the similar C++ syntax would not work as expected, as the
lifetime of the object ends as soon as the assignment is concluded:

\begin{lstlisting}[style=c++]
int main(void) {
    char *s = FMT(std::array<char, 128>{}, "%s %d %f", "str", 42, 3.1415);
    // temporary array (and `s`, by extension) no longer valid here
    std::puts(s);
}
\end{lstlisting}

\subsection{Anachronisms}

The legacy of C's predecessors --- BCPL and B --- is apparent in many aspects of
the language, leading to surprises and ``infelicities'' (\cite{Ritchie1996}).
Section \secref{subsec:c:storage} already mentioned the \texttt{auto} and
\texttt{register} keywords, a relic of BCPL's untyped variables (the former
later resurrected in C++ for automatic type inference).

\paragraph{\texttt{\&\&} and \texttt{||} precedence}

Both of those languages predate the \texttt{\&\&} and \texttt{||} operators.
They instead relied on context-dependent interpretation of the single-character
\texttt{\&} and \texttt{|} operators, which were the familiar bitwise operations
in regular expressions but had the effect of the logical operators inside an
\texttt{if} statement.  This resulted in expressions such as:

\begin{lstlisting}[style=c]
if(x == y & z)
    // ...
\end{lstlisting}

which tests whether \texttt{x} is equal to \texttt{y} and \texttt{z} is not
zero.  This explains the surprising precedence rules for the \texttt{||},
\texttt{\&\&}, \texttt{\&}, \texttt{|}, and \texttt{==} operators (listed here
in increasing order of precedence), and why parentheses are often required in
expressions such as the following:

\begin{lstlisting}[style=c]
if((x & y) == z)
    // ...
\end{lstlisting}

where \texttt{\&} would have lower precedence than \texttt{==} otherwise,
usually not what is intended.

\paragraph{\texttt{struct} members}

The V6 Unix source code contains several occurrences of a curious pattern:

\begin{lstlisting}[style=c]
#define SW 0177570

struct { int integ; };

if(SW->integ == 0)
    // ...
\end{lstlisting}

This syntax is a consequence of several aspects of early compilers
(\cite{Lions1977}).  Casts did not exist at the time, there was a single
namespace for structure members, and there were no checks for the type of
structure used on the left-hand side of the \texttt{->} operator.  This meant
that the expression above was equivalent to the following in modern C:

\begin{lstlisting}[style=c]
if(*(int*)((char*)SW + 0) == 0)
    // ...
\end{lstlisting}

i.e. the value of \texttt{SW} was treated as the memory address of a(n
anonymous) structure containing an integer member at offset \texttt{0}.
